# How payment system works

![Diagram payment system](link ke gdrive)

1. Customer place order to merchant.
2. Merchant route customer to payment form page where detail of the payment can be seen by costumer.
3. Payment form provided by payment gateway, operate strictly bound to the law or any other security standard in the country. Payment gateway also serve other function like risk & froud prevention. The main function of the gateway is to provide customer financila cred to the merchant bank account.
4. The customer cred then transmitted to acuiring bank which processes card payment on behalf of merchant.
5. The 3 & 4 component can be group as PSP (payment service provider) which is a third party companies or acuring bank that provide payment gateway services to businesses.
6. Acuiring bank process validation on the customer card cred and transaction to respected bank card network.
7. Then acuiring bank transmitted all that data to the issuing bank of the customer card, asking for the transaction approval.
8. The issuing bank then will process the validation approval by checking customer card cred, account balance, and profile condition. If all of that good, then it will transmit approval for the transaction back through the same path until it reach the customer.

# Scope of the system

First step is to define the requirements and goals of this system. Main point needs to be discovered is :
- functional requirements
- scope of the problem
- non-functional requirements

**What payment system are we build?**
1. With PSP (paypal, Dana, OVO, dll)
2. Direct connection to card schemes (e.g. visa, mastercard)

# System Requirements

## 1. Functional Requirements

In short, the func req for payment system is to move money from account A to B. But for the main part is about reliability of two POV, business level & technical level like below.

![Functional component diagram](link di gdrive)

### Payment component

Main features are, 
- *Payment service* : display payment status, store order detail
- *PSP Integration*  : secure payment
- *Wallet* : Balance view
- *Ledger*  : Accounting, Analytics

![payment process example](link di gdrive)

1. Customer click the payment menu, generating payment event.
2. This event then transmitted to database to be saved and to payment service which will trigger the PSP to show the payment page corresponds to the PSP service used here.

![example of payment page](link drive)

3. Payment page can be made by apps dev but they need to adhere the regulation to make such page so usually this page are generated by the PSP provider. The data transmitted here are the amount of money & currency type at minimum, but possible to add other necessary info.
4. Then the PSP validate the transaction to acquiring bank/card scheme.
5. When validation complete, PSP will feedback the approval to the payment service so that it can updates the customer wallet balance and save the newest balance to DB. Also send the company changes balances from that transaction to ledger which it will saved the info to DB. Later this info can be used in auditing or Sales analytics

Below is the full chart show the payment component.

![full payment component](link drive)

### Communication type

Two type for communication in programming :
1. *Synchronous*  : process will run sequentially (wait for correspondence process to finish and give feedback for next process). Not tolerant to failure & big latency.
2. *Asynchronous* : processes will run concurrently. Tolerant to failure & big latency.

Usually in system with high traffic like payment system, asynchronous communication is used to make tolerant to failure & big latency so could make the fast-paced system slowing down. But there will be some component of the system that still need to use synchronous communication such as transaction approval process.


# Dealing with payment failure

Most 3 common failures wil be encountered in payment system:
1. *System failure* : network or server failure
2.  *Poison pill errors* : when inbound messages can't be consumed or process
3.  *Functional errors* : No technical errors but the result are invalid

## Guarantee transaction completion

There might be event when one business service down impacting all process to halt resulting the transaction can't be completed.

To prevent this, messaging queue service like *kafka* can be used to store each transaction process happening as one message event. This way each transaction process won't be marked completed until the event successfully saved in kafka event. 

![payment update saved in kafka event](link drive)

Later the responsibility of process completion of data needed for each business processes fall to the consumer/subscriber of that particular data by getting it from kafka.

![payment update event consumed by service](link drive)

This way, if one business service down, the entire transaction process won't be halted.


## Dealing with transient failure

There could also be problem that happens temporarily/intermittent like network failure. For such problem, there are some strategies available : 

1. Retry strategies
    - for this strategy, 2 parameters can be used. # of retry & time between retry.
    - 4 approach for time between retry: 
        - immediate retry
        - fixed intervals
        - incremental intervals
        - exponential back-off (e.g. 2^n interval)
        - ![time between interval approach-1](link drive)
        - ![time between interval approach-2](link drive)
        - this will make the client contributing by not hammering/flooding the overloaded server while the network isn't get up again.
        - if more than one service dependant on one service, adding randomness or jitter when all of thay service accessing this one service. So it will reduce the possibility of that one service being overloaded.
        - ![more than one service dependant on another service](link drive)
2. Timeouts
    - Used to prevent continuous waiting on one process over long period of time
    - after the timeouts done, retry strategy can be used to retry the process
    - key to set timeouts is to find the value high enough for slower process to finish & low enough to stop the feedback that shouldn't arrived.
3. Fallbacks
    - Enable service which dependant on another service result to keep running instead of completely going down when there is failure on another services. as to keep customer  satisfaction
    - the fallback value can be determine from the business rule. E.g. as below.
    - ![fallback example](link drive)

## Dealing with persistent failure

There are 2 common type of this failure :
1. *Poison pill* 
    - a failure because the data/messages need to be process is wrong, so the process will fail no mater how many time it will retry. This type can make the transaction be canceled following the business.
    - To isolate this messages, put this inside a persistent queue usually called dead letter queue so we can debug it later
2. *One of the service is down*
    - The service that should process the messages got down so the process got halted.
    - The approach is to set aside the messages process inside a persistent queue, called normal flow queue, then after service comeback up, process can be continued.

## Idempotency (Avoid double payment)

In short, this concept use a key, called idempotency-key usually from process uuid, to retry the failing process over and over again that won't write same thing to database / make customer pay double.

![idempotency example](link drive)

This concept also make multiple request with same uuid only allow 1 process to be processed. Other will get canceled and notified to customer as 429 too many requests.

![429 error example](link drive)

# Use distributed system

Used this for payment system that cannot handled by one database instances. Benefits : 

1. Allow for redundancy when one database instance with replication across db instances
    - ![redundancy](link drive)
2. Allow more than one payment service to run for the system
    - ![multiple instance for one component](link drive)
3. Allow load balancing to distribute workloads evenly throughout all instances, prevent one component to be overwhelm
    - ![load balancing](link drive)
4. Allow for fault-tolerance when one instance of a component have failure, keeping the process running
    - ![fault-tolerance](link drive)
5. Allow scalability to expand the system size horizontally to fulfill bigger demand
    - ![scalability](link drive)

But in distributed system, communication between 2 node can failed causing data inconsistencies. So, it's necessary to know what consistency level used when do read and write data.

![data inconsistency level](link drive)

![data consistency level](link drive)

# Encryption of data at rest & in-transit

To protect data from breach, we can do as follow.

1. Encrypting data at rest
    - to change the form of data to a form that can't be read without the encryption key in database
    - ![encryption at rest](link drive)
2. Encrypting data in transit
    - same concept with the first point but being done on the network layer
    - 3 approach that can be done is using:
        - VPN to secure communication between device and network
        - TLS to secure communication between two parties (client & server)
        - HTTPS to make secure data transmission across internet
    - ![encryption in transit](link drive)
3. Access control
    - restricting data access to only the authorize user using method such as two-factor authentication or others.
    - ![access control](link drive)
4. Software vulnerability
    - regularly update the software, libraries, and os to the new patch to prevent any vulnerabilities present in the current version 
    - ![software update](link drive)
5. Back-up data
    - if someone able to breach the encrypted data an re-encrypt that data, this is the same as data loss as that person can make requests for money in return for the data.
    - if the data is back-up regularly, this problem can be prevented
    - ![backup data](link drive)
6. Use uncommon password
    - if the password being used is a worded password (short & easy-to-guess word), the hacker can guess the pass using rainbow table to decode the hashed password for example
    - use long uncommon pass to prevent this
    - ![uncommon password](link drive)

# Data integrity monitoring

A powerful security technique to secure data by checking whether there is changes been made to vulnerable data with workflow as below : 
1. Generate cryptographic checksum as baseline
2. Regularly generate new checksum and compare to the baseline.
3. If both value different, there can be some breach detected to that particular data

![data integrity monitoring](link drive)

This method needs to be used carefully as the checksum process consume a lot of resource as the data getting bigger. So below is the list of common data that this method can be applied.

![cryptographic checksum](link drive)

# Conclusion

![Conclusion](link drive)


